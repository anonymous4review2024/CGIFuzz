# This wrapper, to communicate to a fuzzer via TCP.
# Copyright (c) 2022 Robert Bosch GmbH
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
from __future__ import annotations

import socket
import struct

from CGIFuzz.fuzz_wrappers.FuzzWrapper import FuzzWrapper


class TCPFuzzWrapper(FuzzWrapper):
    """Abstraction for fuzzer.

    TCP Sockets are used to communicate with the fuzzer.

    Sent Message structure: | Message Type | (Optional) Content Length |
                            | (Optional) Content |
        Message Type is encoded in 1 byte.
        Content Length is encoded in 4 bytes and it specifies the length of
                       Content in bytes.
        Content depepends on the Message Type. For example if type is 2, the
                Content includes the coverage data.
    Message Type - Description
    1 - Request for an input, generated by the fuzzer.
    2 - Info from the FuzzWrapper to the Fuzzer about the coverage reached.

    Received Message structure: | Content Length | Content |
    """

    def __init__(self, server_port: int, server_hostname: str = "localhost"):
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.connect((server_hostname, server_port))

    # TODO: i spent a lot of time in here. I can increase perf later
    def generate_input(self, _: bytes) -> bytes:
        message_type = struct.pack('b', 1)
        self.send_message(message_type)
        return self.receive_message()

    def report_coverage(
            self,
            current_input: bytes | None,
            address: int
    ) -> None:
        message_type = struct.pack('b', 2)
        self.send_message(message_type)
        addresses_bytes = struct.pack("Q", address)

        self.send_message(addresses_bytes, prepend_length=True)

    def send_message(
        self,
        message: bytes,
        prepend_length: bool = False
    ) -> None:
        if prepend_length:
            message_len = struct.pack("I", len(message))
            self.s.send(message_len)
        self.s.send(message)

    def receive_message(self) -> bytes:
        message_len = int.from_bytes(self.s.recv(4), 'little')
        message = self.s.recv(message_len)
        return message


if __name__ == '__main__':
    fuzzer_wrapper = TCPFuzzWrapper(8082)
